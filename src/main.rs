use serde::{Deserialize, Serialize};
use serde_ply::{ElementDef, PlyFormat, PlyHeader, PropertyType, ScalarType};
use std::io::Cursor;

#[derive(Serialize, Deserialize, Debug)]
struct Vertex {
    x: f32,
    y: f32,
    z: f32,
}

#[derive(Serialize, Deserialize, Debug)]
struct Face {
    vertex_indices: Vec<u32>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Example PLY file content
    let ply_data = r#"ply
format ascii 1.0
comment A simple triangle
element vertex 3
property float x
property float y
property float z
element face 1
property list uchar int vertex_indices
end_header
0.0 0.0 0.0
1.0 0.0 0.0
0.5 1.0 0.0
3 0 1 2
"#;

    // Parse the header first to understand the structure
    let cursor = Cursor::new(ply_data);
    let (header, bytes_read) = PlyHeader::parse(cursor)?;

    println!("=== PLY Header Information ===");
    println!("Format: {}", header.format);
    println!("Version: {}", header.version);
    println!("Comments: {:?}", header.comments);

    for element in &header.elements {
        println!("\nElement: {} (count: {})", element.name, element.count);
        for property in &element.properties {
            match property {
                PropertyType::Scalar { data_type, name } => {
                    println!("  Property: {name} ({data_type:?})");
                }
                PropertyType::List {
                    count_type,
                    data_type,
                    name,
                } => {
                    println!(
                        "  List Property: {name} (count: {count_type:?}, data: {data_type:?})"
                    );
                }
            }
        }
    }

    println!("\n=== Header parsed, {bytes_read} bytes consumed ===");

    // Demonstrate creating a new PLY header programmatically
    let new_header = PlyHeader {
        format: PlyFormat::Ascii,
        version: "1.0".to_string(),
        elements: vec![ElementDef {
            name: "vertex".to_string(),
            count: 3,
            properties: vec![
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "x".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "y".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "z".to_string(),
                },
            ],
        }],
        comments: vec!["Generated by serde_ply example".to_string()],
        obj_info: vec![],
    };

    // Example vertices
    let vertices = [Vertex {
            x: 0.0,
            y: 0.0,
            z: 0.0,
        },
        Vertex {
            x: 1.0,
            y: 0.0,
            z: 0.0,
        },
        Vertex {
            x: 0.5,
            y: 1.0,
            z: 0.0,
        }];

    println!("\n=== Serialization Example ===");

    // Serialize to string
    let mut output = Vec::new();
    let mut serializer = serde_ply::PlySerializer::with_header(&mut output, new_header);

    // Write header manually for demonstration
    serializer.set_header(PlyHeader {
        format: PlyFormat::Ascii,
        version: "1.0".to_string(),
        elements: vec![ElementDef {
            name: "vertex".to_string(),
            count: vertices.len(),
            properties: vec![
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "x".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "y".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "z".to_string(),
                },
            ],
        }],
        comments: vec!["Generated PLY file".to_string()],
        obj_info: vec![],
    });

    println!("Generated PLY structure for {} vertices", vertices.len());
    println!("Each vertex has properties: x, y, z (float)");

    Ok(())
}
