//! Binary PLY writing example

use serde::{Deserialize, Serialize};
use serde_ply::{
    elements_to_bytes, elements_to_writer, ElementDef, PlyFormat, PlyHeader, PropertyType,
    ScalarType,
};

use std::io::{BufReader, Cursor};

#[derive(Serialize, Deserialize, Debug, PartialEq)]
struct Vertex {
    x: f32,
    y: f32,
    z: f32,
    red: u8,
    green: u8,
    blue: u8,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
struct Face {
    vertex_indices: Vec<u32>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
struct VertexWithNormal {
    x: f32,
    y: f32,
    z: f32,
    nx: f32,
    ny: f32,
    nz: f32,
    quality: f64,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let vertices = vec![
        Vertex {
            x: 0.0,
            y: 0.0,
            z: 0.0,
            red: 255,
            green: 0,
            blue: 0,
        },
        Vertex {
            x: 1.0,
            y: 0.0,
            z: 0.0,
            red: 0,
            green: 255,
            blue: 0,
        },
        Vertex {
            x: 0.5,
            y: 1.0,
            z: 0.0,
            red: 0,
            green: 0,
            blue: 255,
        },
    ];

    let header = PlyHeader {
        format: PlyFormat::BinaryLittleEndian,
        version: "1.0".to_string(),
        elements: vec![ElementDef {
            name: "vertex".to_string(),
            count: vertices.len(),
            properties: vec![
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "x".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "y".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "z".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::UChar,
                    name: "red".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::UChar,
                    name: "green".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::UChar,
                    name: "blue".to_string(),
                },
            ],
        }],
        comments: vec!["Generated by serde_ply".to_string()],
        obj_info: vec![],
    };

    // Generate binary data
    let binary_data = elements_to_bytes(&header, &vertices)?;

    // Test writing to memory buffer
    let mut buffer = Vec::new();
    elements_to_writer(&mut buffer, &header, &vertices)?;

    // Round-trip validation
    let cursor = Cursor::new(&binary_data);
    let mut reader = BufReader::new(cursor);
    let parsed_header = serde_ply::PlyHeader::parse(&mut reader)?;
    let deserialized: Vec<Vertex> =
        serde_ply::parse_elements(&mut reader, &parsed_header, "vertex")?;

    // Verify data integrity
    assert_eq!(vertices.len(), deserialized.len());
    for (original, recovered) in vertices.iter().zip(deserialized.iter()) {
        assert_eq!(original, recovered);
    }

    let large_dataset = generate_test_vertices(1000);
    let ascii_header = create_vertex_header(PlyFormat::Ascii, large_dataset.len());
    let binary_header = create_vertex_header(PlyFormat::BinaryLittleEndian, large_dataset.len());
    let ascii_data = elements_to_bytes(&ascii_header, &large_dataset)?;
    let binary_data = elements_to_bytes(&binary_header, &large_dataset)?;

    // Verify binary is smaller and faster
    assert!(binary_data.len() < ascii_data.len());

    // Test different endianness
    let little_endian_header = create_vertex_header(PlyFormat::BinaryLittleEndian, vertices.len());
    let big_endian_header = create_vertex_header(PlyFormat::BinaryBigEndian, vertices.len());

    let little_data = elements_to_bytes(&little_endian_header, &vertices)?;
    let big_data = elements_to_bytes(&big_endian_header, &vertices)?;

    assert!(!little_data.is_empty());
    assert!(!big_data.is_empty());

    // Complex data types
    let complex_vertices = vec![
        VertexWithNormal {
            x: 1.0,
            y: 2.0,
            z: 3.0,
            nx: 0.0,
            ny: 0.0,
            nz: 1.0,
            quality: 0.95,
        },
        VertexWithNormal {
            x: 4.0,
            y: 5.0,
            z: 6.0,
            nx: 0.57735,
            ny: 0.57735,
            nz: 0.57735,
            quality: 0.87,
        },
    ];

    let complex_header = PlyHeader {
        format: PlyFormat::BinaryLittleEndian,
        version: "1.0".to_string(),
        elements: vec![ElementDef {
            name: "vertex".to_string(),
            count: complex_vertices.len(),
            properties: vec![
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "x".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "y".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "z".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "nx".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "ny".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "nz".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Double,
                    name: "quality".to_string(),
                },
            ],
        }],
        comments: vec!["Complex vertex with normals and quality".to_string()],
        obj_info: vec![],
    };

    let complex_data = elements_to_bytes(&complex_header, &complex_vertices)?;

    // Verify round-trip for complex data
    let recovered_complex: Vec<VertexWithNormal> = {
        let cursor = Cursor::new(&complex_data);
        let mut reader = BufReader::new(cursor);
        let header = serde_ply::PlyHeader::parse(&mut reader)?;
        serde_ply::parse_elements(&mut reader, &header, "vertex")?
    };

    for (original, recovered) in complex_vertices.iter().zip(recovered_complex.iter()) {
        assert_eq!(original, recovered);
    }

    Ok(())
}

fn create_vertex_header(format: PlyFormat, count: usize) -> PlyHeader {
    PlyHeader {
        format,
        version: "1.0".to_string(),
        elements: vec![ElementDef {
            name: "vertex".to_string(),
            count,
            properties: vec![
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "x".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "y".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::Float,
                    name: "z".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::UChar,
                    name: "red".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::UChar,
                    name: "green".to_string(),
                },
                PropertyType::Scalar {
                    data_type: ScalarType::UChar,
                    name: "blue".to_string(),
                },
            ],
        }],
        comments: vec!["Generated by serde_ply binary writing example".to_string()],
        obj_info: vec![],
    }
}

fn generate_test_vertices(count: usize) -> Vec<Vertex> {
    (0..count)
        .map(|i| {
            let t = i as f32 / count as f32;
            Vertex {
                x: t * 10.0,
                y: (t * std::f32::consts::PI * 2.0).sin() * 5.0,
                z: (t * std::f32::consts::PI * 4.0).cos() * 2.0,
                red: (t * 255.0) as u8,
                green: ((1.0 - t) * 255.0) as u8,
                blue: ((t * 2.0) % 1.0 * 255.0) as u8,
            }
        })
        .collect()
}
